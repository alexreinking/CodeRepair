\section{Algorithm Description}
\subsection{Graph Construction}

The data structure central to \ourTool is a colored, directed, weighted, simple bipartite graph $G = (V_t \cup V_m, E)$ between \textit{type} nodes ($V_t$) and \textit{map} nodes ($V_m$). A type is any concrete data type, and a map is any language entity that produces exactly one data type (possibly void) from zero or more types, i.e. it can be modelled by some map $f : (\tau_1 \times \cdots \times \tau_k) \to \sigma$. In the graph, for each map, an incoming edge is drawn from its co-domain, and outgoing edges are drawn from the map to each type in its domain. These relationships capture the notions that each type or map can be \textit{constructed from} or \textit{satisfied by} other maps or types, respectively. The graph is colored according to which kind of language structure added the node to the graph.

Although the definitions of type and map are language-agnostic, our implementation targets Java for its ease of analysis. In Java, we add type nodes to the graph for each class and for each primitive type. The map nodes are derived from methods, static functions, constructors, local methods, and values (which take void to their own data type), and are colored according to each category. These colors are used by the synthesis procedure to decide how to construct the strings that ultimately occur as output.
