\clearpage

\section{Algorithm Description}
\subsection{Graph Construction}

The data structure central to \ourTool is a colored, directed, weighted, simple bipartite graph $G = (V = V_t \cup V_m, E, w, c)$ between \textit{type} nodes ($V_t$) and \textit{map} nodes ($V_m$). A type is any concrete data type, and a map is any language entity that produces exactly one such data type (possibly void) from zero or more types, i.e. it can be modeled by some map $f : (\tau_1 \times \cdots \times \tau_k) \to \sigma$. In the graph, for each map, an incoming edge is drawn from its co-domain, and outgoing edges are drawn from the map to each type in its domain. These relationships capture the notions that each type or map can be \textit{constructed from} or \textit{satisfied by} other maps or types, respectively.

The weights on the graph represent the \textit{cost} incurred by including the edge as a part of a candidate snippet. These weights can be derived according to simple heuristics, or computed by examining the frequency of usage over a large corpus. It is important only that no negative costs be assigned anywhere in the graph, and that methods that are more important are valued more than those that are not. The algorithm evaluates candidate expressions by considering their \textit{cost}, not their \textit{value}, so lower edge weights are considered better. Lastly, the graph is colored according to which language structure added the node to the graph, e.g. constructors, methods, public fields, and the like. These groups color the graph, and are used by the synthesis procedure to decide how to construct the code snippets that ultimately serve as output.

\subsection{Synthesis Procedure}

Using this graph, we can answer type-inhabitation queries. That is, given a type $\tau$, we seek expressions of that type that are of low cost. Naturally, we have set the costs so that those expressions that are most desirable are found early on by the algorithm. The \ref{proc:synthesize} procedure, outlined below, answers these queries.

The method proceeds by growing a Dijkstra shortest path ball in the graph of a specified size. This parameter, $L$, acts as a cost limit for the search, and can be tuned to provide a reasonable balance between speed and accuracy, depending on the chosen weighting scheme. The induced subgraph over those nodes is then recursively searched for type satisfaction by \ref{proc:getExpression}, which is called \textit{leaves-first} to enable memoization of its results. Since each type is passed a limit equal to the greatest possible remaining cost during a search from $\tau$, the whole (reduced) space of results is considered for each type. Once a type is settled, the result is added to a memoization table to speed up future calls.

The other tuning parameter, $N$, can be provided to bound both the total number of expressions returned and the number of intermediate results at any given depth by $N$. Because all of the possible generators are considered regardless, we can be sure that the algorithm does not miss any possibilities during the search that might appear among the $N$ best results.

\SetKw{KwNew}{new}
\SetKw{KwIn}{in}
\SetKw{KwNot}{not}
\SetKw{KwWhere}{where}
\SetKw{KwContinue}{continue}
\begin{procedure}
$(V_t\cup V_m, E, w, c)$ $\leftarrow$ $G$ \;
$(D_t, D_m)$ $\leftarrow$ nodes distance less than $L$ away from $\tau\in V_t$\;
\tcc{$D_t, D_m$ ascending by Dijkstra's}
genTable $\leftarrow$ $\left\{\left\{\right\}\right\}$ \;
snippetTable $\leftarrow$ $\left\{\left\{\right\}\right\}$ \;
\ForEach{$(f : (\tau_1 \times \cdots \times \tau_k) \to \sigma) \in D_m$}{
	\tcc{Keep only the best $N$ elements}
	genTable[$\tau$] $\leftarrow$ genTable[$\tau$] $\cup$ $\{(f, w(f))\}$ \;
}
typeStack $\leftarrow$ \KwNew Stack\;
\ForEach{$\sigma \in D_t$}{
	push $(\sigma, L-\text{shortestPathLength}(\sigma))$ on to typeStack\;
}
\While{typeStack is not empty}{
	$(\sigma, l)$ $\leftarrow$ pop typeStack \;
	snippetTable[$\sigma$] $\leftarrow$ \ref{proc:getExpression}(genTable, snippetTable, $\sigma$, $l$, $N$) \;
}
\Return{snippetTable[$\tau$]}\;
\caption{Synthesize($G$, $\tau$, $L$, $N$)}
\label{proc:synthesize}
\end{procedure}

Note that in \ref{proc:synthesize}, all sets are maintained in sorted order using a tree data structure, and \textit{genTable} and \textit{snippetTable} are both hash tables of these sets.

The next procedure, \ref{proc:getExpression}, goes through each possible generator for a given type and attempts to satisfy its parameter types recursively. It checks the memoization table before computing to avoid repeating work. The recursion itself is straight-forward: for each function that can generate the requested type, attempt to satisfy each one of its parameters, add all those whose parameters were satisfied and whose total cost is beneath the limit $L$, and keep only the best $N$ encountered. Larger values of $N$, of course, increase the time required at this stage.

\begin{procedure}
\lIf{$\tau$ $\in$ snipT}{\Return{snipT[$\tau$]}}
snips $\leftarrow$ $\{\}$ \;
gens $\leftarrow$ genT[$\sigma$] \;
\ForEach{$(f : (\tau_1 \times \cdots \times \tau_k) \to \sigma, w')$ $\in$ gens}{
	\lIf{$w' > L$}{\KwContinue}
	$s_i$ $\leftarrow$ \ref{proc:getExpression}(genT, snipT, $\tau_i$, $L - w'$, $N$) $\forall i$\;
	\ForEach{args $\in$ $s_1 \times \cdots \times s_k$}{
		cost $\leftarrow$ $w' + \sum_{i=1}^{k} w(args[i])$ \;
		exp $\leftarrow$ $(f(args), cost)$ \;
		\If{cost $\leq L \wedge | \text{snips} | < N$}{
			snips $\leftarrow$ snips $\cup$ $\{$ exp $\}$ \;
		}
		\ElseIf{cost $\leq L \wedge | \text{snips} | = N$}{
			$e'=(maxE, maxCost)$ $\leftarrow$ popMax(snips) \;
			snips $\leftarrow$ snips $\cup$ $\{$ min($e'$, exp) $\}$
		}
	}
}
\Return{snippets}
\caption{GetExpressions(genT, snipT, $\sigma$, $L$, $N$)}
\label{proc:getExpression}
\end{procedure}

Since $L$ and $N$ simply limit the search, setting both to $\infty$ enables a search of the entire possible space of expressions that generate type $\tau$.

\subsection{Repair Procedure}

% \digraph[scale=0.5]{MyGraph}{rankdir=LR; a->b; b->c}

\lipsum[1-36]
