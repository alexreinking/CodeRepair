\section{Motivating Examples}
\label{sec:examples}

We begin with a series of examples that show how to apply \ourTool in practical software
development. These examples are written in the Java programming
language. As formally defined in Sec.~\ref{sec:preliminaries},
as input our algorithm takes terms in applicative long normal
form, which closely corresponds to expressivity of the Java programming language.
To emphasize the significance in practical software development, 
we choose examples from a set of the real code examples (most of them featured at
\url{http://www.java2s.com/}{}).

%
%
%We first illustrate our approach and the nature of repair with the usage of
%familiar API calls from the Java standard library, reflecting along the way on the differences
%between our and other approaches for code completion and repair.
%We then present somewhat more complex examples which illustrate the reach and
%the expressiveness in terms of possible expressions accepted as
%inputs and produced as outputs when using our automated code repair.
%In order


\subsection{Sequence of streams}

We start by showing how our algorithm handles a given backbone 
expression that does not compile. This example is similar to the 
example presented in the InSynth paper
\cite{GveroETAL13CompleteCompletionTypesWeights}, so this way we can compare and 
demonstrate the differences between InSynth and our algorithm. Consider the following program fragment:
\begin{lstlisting}
import java.io.*;

public class Main {
  public static void main(String args[]) throws IOException {
    String body = "email.txt";
    String sig = "sign.txt";
    
    SequenceInputStream seqStream = new SequenceInputStream(body, sig) // error
    // ..., rest of the code is omitted
  }
} 
\end{lstlisting}
The developer declared the variable \lstinline{seqStream}; however, the specified 
expression assigned to \lstinline{seqStream} does not compile. Still, from this backbone expression 
we can recognize the structure of the intended expression: our algorithm should construct 
an expression that preserves the relative position of the declarations from 
\lstinline{SequenceInputStream(body, sig)}. In the resulting expression a \lstinline{SequenceInputStream} constructor
should be used, with arguments that contain \lstinline{body} and \lstinline{sig} variables in their
corresponding sub-expression trees. Our repair algorithm finds all such expressions, 
constructed from the
declarations visible in the scope of the backbone expression. The found expressions are well-typed 
and ranked according to a metric that characterizes the
resemblance to the starting backbone expression.
The returned expression with the highest rank is
\begin{lstlisting}
SequenceInputStream seqStream = new SequenceInputStream(
  new FileInputStream(body), new FileInputStream(sig))
\end{lstlisting}
This expression represents exactly the desired expression.
When we ran \cite{GveroETAL13CompleteCompletionTypesWeights} on the exactly same example, but without 
the backbone expression, the desired expression was
ranked as the second highest. Our new algorithm outperformed InSynth on this example, showing
that the backbone expression can increase the quality of returned results by InSynth.

An additional advantage that our repair algorithm has over InSynth is handling of constants. 
As an illustration, given the backbone expression:
\begin{lstlisting}
SequenceInputStream seqStream = new SequenceInputStream("email.txt", "sign.txt") 
\end{lstlisting}
our algorithm returns, as expected:
\begin{lstlisting}
SequenceInputStream seqStream = new SequenceInputStream(
  new FileInputStream("email.txt"), new FileInputStream("sign.txt"))
\end{lstlisting}
In InSynth we were not able to synthesize code snippets with arbitrary literals. 
This way our code repair algorithm can be considered as an improved synthesis algorithm,
because it also incorporates explicitly given literals in the final snippets.

%
%In this example, the developer's hint in terms of the broken expression
%unambiguously determines the result - it drives the repair process to
%produce the desired expression as the repaired expression with the highest rank.
%This shows that with giving the developer the possibility to specify
%the intent with additional constraints in terms of an expression that
%resembles the desired one, our approach can be very effective in driving the
%repair and finding the expression the developer had in mind.

\subsection{Use of coercion functions}

Many programming languages support coercion functions \cite{TannenCoercionS91}. 
They are used for type conversion and can be applied automatically if needed, 
without the direct intervention from the developer. An automated insertion of
coercion functions is utilized for the purpose of fixing ill-typed
expressions in many modern compilers, but usually in a limited manner 
(at most one coercion function can be used to fix an ill-typed expression).
Our repair algorithm goes beyond this standard and allows more expressive transformations of
ill-typed expressions. The algorithm is based on advanced methods for searching and adapting 
appropriate functions, combined with synthesizing any additional necessary
arguments.

Consider the following code, in which the developer declares a byte buffer and
wants to construct an expression of the type \lstinline{InputStream} by merely hinting
the desired type and usage of the declared buffer \lstinline{b}:
\begin{lstlisting}
import java.io.*;

public class Main {
  public static void main(String args[]) throws IOException {
    int off = 8, len = 512, size = 1024;
    byte b[] = args[0].getBytes();
    
    InputStream input = b; // error
  }
}
\end{lstlisting}
To repair the expression that initialize the variable \lstinline{input}, 
we insert a coercion function (here represented as a constructor application):
\begin{lstlisting}    
InputStream input = new ByteArrayInputStream(b);
\end{lstlisting}
Our algorithm returns this expression as the highest ranked expression: 
the expression is well-typed, follows the simple structure of the backbone
expression \lstinline{b}, with the smallest size.
The upcasting done in this case can be seen as an implicit insertion of 
a coercion function, which casts \lstinline{ByteArrayInputStream} to
its superclass, \lstinline{InputStream}.

Our repair algorithm finds additional well-typed expressions, such as 
\begin{lstlisting}    
InputStream input = new ByteArrayInputStream(b, off, len);
\end{lstlisting}
This expression also correctly
repairs the given backbone expression, but it no longer represents a simple coercion
function insertion. It is the \lstinline{ByteArrayInputStream} overloaded 
constructor with three arguments. To create this expression, our algorithm
considers a broader range of available functions and finds appropriate
expressions that fill the places of the missing arguments. Those arguments
are synthesized whenever a type-conversion function requires additional parameters.

%The functions visible at the program point where the algorithm is invoked.
% The algorithm can use all functions in the scope to repair the ill-typed expression.
% Here is another candidate expression our algorithm generates, more complex and longer, but valid
% result of the repair algorithm:
% \begin{lstlisting}    
% InputStream input = new SequenceInputStream(
%   new ByteArrayInputStream(b, off, len), new BufferedInputStream(System.in, size));
% \end{lstlisting}
%We can see that our approach can use all visible declarations to construct expressions of
%arbitrary complexity in place of \textit{boarding arguments} if necessary.
%The only restriction of such repair is that the resulting expression must follow
%the structure of the given broken expression in a certain manner (as an example, in this
%expression, the second argument to the \lstinline{SequenceInputStream} constructor may not
%contain \lstinline{b} in its expression).

\subsection{Mutations of ill-typed expressions}

%We next illustrate that our approach also considers modifications to the
%given ill-typed expression itself, i.e. mutations of it, during the search for
%the best fitting repair expression.

%The next example extensively uses calls to the
%standard Java API library for manipulation of streams.
Sometimes the developer writes an ill-typed expression that less reflects
the structure of the desired expression, usually by giving a wrong order
or number of arguments. Consider the following code that extensively uses
calls to the standard Java API library to manipulate streams.
The given backbone expression expresses a users wish to read a file 
compressed with the ZLIB library through a buffered stream.
To read the file a user would need an \lstinline{InputStream} object.
\begin{lstlisting}
import java.io.*;
import java.util.zip.*;

public class Main {
  public static void main(String args[]) throws IOException {
    int buffSize = 1024, compLevel = Deflater.BEST_SPEED;
    String fileName = "compressed.txt";
    
    InputStream input = new BufferedInputStream(buffSize,
      new DeflaterInputStream(new FileInputStream, compLevel, true)); // error
  }
}
\end{lstlisting}

However, a user writes arguments of the \lstinline{BufferedInputStream} constructor in a wrong order.
In such a scenario our algorithm enumerates all the mutations of the abstract syntax
tree given by the backbone expression. The algorithm then searches exhaustively
all possible valid expressions considering a large number of different syntax trees.
Those abstract syntax trees effectively correspond to useful modifications
at the source code level, such as reordering, deletion or insertion of function arguments.

To create a desired expression our algorithm has to change the order of
the \lstinline{BufferedInputStream} arguments in the initial backbone expression.
After applying a set of further modifications to the arguments we arrive to 
the new backbone expression. In the last phase we fix the backbone expression
inserting \lstinline{Deflater} constructor. The correct expression looks like:
\begin{lstlisting}    
InputStream input = new BufferedInputStream(new DeflaterInputStream(
  new FileInputStream(fileName), new Deflater(compLevel, true)), buffSize);
\end{lstlisting}
Each mutation of an initial backbone expression introduces additional penalty 
in terms of the resulting rank.
% mozda treba pomenuti da algoritam moze naci i gluplji expression sa mozda
% vecim rankom -> ne treba, prevelika je vec sekcija, i ovo cu baciti
% jer nemamo experimental evaluation.
%
%We have shown that our approach can perform a search through a large number of
%possible repair expressions and guides it according to the appropriate metric
%that characterizes the distance from the given broken expression.
%From this demonstration we postulate that the approach can indeed perform useful
%and effective repairs that are well aligned with the developer's intent, even in
%cases where the given broken expression is very distant from it.  
