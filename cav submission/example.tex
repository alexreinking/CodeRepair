\section{Motivating Examples}
\label{sec:examples}
We first illustrate how our algorithm works and the nature of repair with the usage of familiar API calls from the Java standard library, reflecting along the way on the differences between our and other tools for code completion and repair. To emphasize the significance in practical software development, our examples are chosen from a set of the real code examples (most of them featured at \url{http://www.java2s.com/}{}).

\subsection{Code Correction: Single Error}
\label{sec:examples:single}
The following simple example, adapted from \cite{GveroETAL13CompleteCompletionTypesWeights}, illustrates how our algorithm handles an expression that does not compile. Consider the following program fragment:
\begin{lstlisting}
public class Main {
  public static void main(String args[]) throws IOException {
    String body = "email.txt"; String sig = "sign.txt";
    SequenceInputStream seqStream = new SequenceInputStream(body, sig); // error
  }
} 
\end{lstlisting}
Here, the developer has given the \lstinline{SequenceInputStream} constructor two strings, even though none of its overloads accept those arguments. Still, we can recognize the intent of the intended expression. To preserve this intent, our algorithm should construct an expression that maintains the relative position of the original arguments. The corrected expression should favor reusing the well-typed subexpressions, such as the \lstinline{body} and \lstinline{sig} variables in their corresponding sub-expression trees. Our algorithm finds all such expressions, constructed from the visible declarations in the current scope. The results are well-typed and ranked according to a metric that favors resemblance to the starting expression.

In this case, the returned expression with the lowest cost is \lstinline{new SequenceInputStream(new FileInputStream(body), new FileInputStream(sig))}, which precisely reflects the programmer's intent.

\subsection{Code Correction: Multiple Errors}
\label{sec:examples:multiple}
Sometimes, an ill-typed expression poorly reflects the structure of the desired expression, while still retaining other useful information. Often, the structure is obscured by passing too many or too few arguments arguments to a function, or by passing them in the wrong order.

The following code fragment uses an extensive number of calls to the standard Java API library with the intention to read a compressed file though a buffered stream. The developer attempts to instantiate an \lstinline{InputStream} object:
\begin{lstlisting}
public class Main {
  public static void main(String args[]) throws IOException {
    int buffSize = 1024, compLevel = Deflater.BEST_SPEED;
    String fileName = "compressed.txt";
    
    InputStream input = 
      new BufferedInputStream(buffSize, new DeflaterInputStream(
        new FileInputStream(), compLevel, true)); // error 
  }
}
\end{lstlisting}
In this example, the single expression contains three errors. First, the \lstinline{FileInputStream} constructor requires at least one argument; second, the \lstinline{DeflaterInputStream} constructor has been passed too many arguments; and finally, the \lstinline{BufferedInputStream} has been passed valid arguments in the wrong order.

To repair this expression, our algorithm proceeds from the bottom, viewed as a parse tree, up to the top-level. Thus, it begins correcting the sub-expression \lstinline{new FileInputStream()}. The algorithm draws on the environment to produce \lstinline{new FileInputStream(fileName)} as the closest match.

After applying this repair, it proceeds to correct the \lstinline{DeflaterInputStream}. Since all of its arguments are now well-typed, the repair will attempt to re-use them while synthesizing a replacement. The algorithm wraps the extra arguments in a call to the \lstinline{Deflater} constructor from the Java API.

Finally, it rebuilds the overall expression by interchanging the arguments in the top-level expression to arrive at the final, correct result:
\begin{lstlisting}   
new BufferedInputStream(new DeflaterInputStream(
  new FileInputStream(fileName), new Deflater(compLevel, true)),
    buffSize);
\end{lstlisting}

These examples show how our algorithm efficiently searches through a large number of possible repair expressions, and guides that procedure according to an appropriate metric that values shorter distances between the given expression and the corrected expression. We believe that our algorithm will perform useful and effective repairs that are well-aligned with the developer's intentions, even when the given ill-typed expression requires several steps to repair.
