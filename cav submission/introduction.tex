\section{Introduction}
\label{sec:intro}
Software developers enjoy a high degree of freedom in their approach to writing code. Still, when writing a program, the developer needs to follow the strict rules determined by the programming language. While coding, a developer often knows the approximate structure of the expression she is working on, but may yet write code that does not compile because some fragments are not well-typed. Such mistakes occur mainly because the developer does not know by heart how to choose and properly combine all the declarations necessary to achieve her ends. By the term ``declarations'', we refer to all the elements visible in the scope, such as variables, functions, and class declarations.

Moreover, since modern libraries often evolve into complex application programming interfaces (APIs) that provide a large number of declarations, it is difficult, if not impossible, to learn the specifics of every declaration and its utilization. In a typical scenario when code does not compile, the compiler outputs an error message indicating the source of the error. Still, on many occasions the written expression reflects the intended structure of the code.

In this paper we propose an approach that takes such an ill-typed expression and automatically suggests a list of possible well-typed corrections. The suggested code snippets follow the structure outlined in the given ill-typed expression as closely as possible, and they are ranked based on their similarity to the original code. Furthermore, this approach can also be seen as code synthesis. In fact, our proposed method extends the synthesis functionality described in \cite{MandelinetALL2005Jungloid, GveroETAL13CompleteCompletionTypesWeights, PerelmanGBG12}. In light of program repair, plain expression synthesis can be seen as a repair of the empty expression.

% The repair algorithm is based on encoding of type constraints derived from signatures into a so-called {\emph {synthesis graph}}. In summary, finding a well-typed code repair corresponds to incrementally applying a search algorithm on the synthesis graph, while preserving the cost constraints.

We have implemented an early prototype of our algorithm, and empirically tested it on synthesis and repair benchmarks. The initial evaluation strongly supports the idea of a graph-based type-directed approach to code repair and snippet synthesis. Compared to the results reported in \cite{GveroETAL13CompleteCompletionTypesWeights}, our approach outperforms on similar benchmarks, sometimes by several orders of magnitude, while still producing high-quality results.
