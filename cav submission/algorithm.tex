\section{The Algorithm}
\label{sec:algorithm}

Our algorithm operates by searching through a specially-crafted data structure called the synthesis graph. Each node of the synthesis graph corresponds to either a value-producing language entity, such as a function, variable, constant, or literal, or to a type in the language. Since variables, constants, and literals can be considered functions taking the empty set to their value, we call all nodes of the former type ``function nodes''. From each function node, we draw an out-edge to the type it produces, and for each distinct type the function takes as an argument, we draw an incoming edge into the function node to the type node. Importantly, this means that a function on three input parameters of the same type will have in-degree exactly one.

Each vertex is labeled by the full function signature so that well-typed expressions can be synthesized. The edges in the graph are weighted by their cost of inclusion -- a subjective measure -- that guides the search towards desirable traits, such as smaller expressions or lower memory usage.

The algorithm uses two procedures, along with some supporting subroutines, to accomplish expression repairs by referring to this graph. The repair algorithm itself degenerates into simple expression synthesis when presented with an empty broken expression, and as such subsumes the functionality described in \cite{GveroETAL13CompleteCompletionTypesWeights}. Furthermore, the algorithm can be seen as a generalization of the Prospector algorithm described in \cite{MandelinetALL2005Jungloid}, since their construction can be embedded within ours if only unary operations and types are added to the graph.

\subsection{Synthesis Procedure}
We will now describe the synthesis portion of our algorithm, which is presented as pseudocode in algorithm \ref{proc:synthesize}. Note that to distinguish type nodes $V_t$ from function nodes $V_f$, we will write the synthesis graph $G=(V_t \cup V_f, E)$.

\begin{algorithm}
\SetKwData{Exprs}{exprs}\SetKwData{Snips}{snips}
\SetKwFunction{Dist}{Dist}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{$G=(V_t\cup V_f,E)$, the synthesis graph; $\tau \in V$, the type to synthesize; $\delta$, the maximum allowable cost; $L$, the number of snippets to synthesize}
\Output{\Exprs, the list of expressions}
\BlankLine
$G'=(V_t'\cup V_f', E') \longleftarrow$ subgraph of $G$ reachable within $\delta$ from $\tau$ \;
Sort $V_t'$ in descending distance away from $\tau$ \;
\Snips[$\sigma$] $\longleftarrow$ Hash table mapping types to snippets \;
\ForEach{$\sigma\in V_t'$}{
  \Snips[$\sigma$] $\longleftarrow$ \ref{proc:getExpressions}($G'$, \Snips, $\sigma$, $\delta - $ \Dist{$\sigma$}, $L$) \;
}
\Exprs $\longleftarrow$ \Snips[$\tau$] \;
\caption{Synthesis Algorithm}\label{proc:synthesize}
\end{algorithm}

The synthesis logic itself is clear, the subgraph is derived by using Dijkstra's algorithm, which can also accomplish the vertex sort by distance. We go in reverse order so as to cache at the latest possible opportunity. At any stage of the loop, we know that $\sigma$ is as close as possible to $\tau$ and so if we create an expression for $\tau$ that involves $\sigma$ along the way, we know that the rest of the expression may cost at most $\delta - $ \Dist{$\sigma$}. The procedure \ref{proc:getExpressions} 
